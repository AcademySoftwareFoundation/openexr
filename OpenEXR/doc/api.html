<html>
<head>
	<title>OpenEXR</title>
</head>

<body bgcolor=#ffffff fgcolor=#000000>

<h2>Reading and Writing OpenEXR Image Files with the IlmImf Library</h2>
<p>

This document shows how to write C++ code that reads and writes OpenEXR
image files.   The text assumes that the reader is familiar with OpenEXR
terms like "channel", "attribute", or "data window".  For an explanation
of those terms, see
<a href="details.html">details.html</a>.
The OpenEXR source distribution contains a subdirectory, IlmImfExamples,
with most of the code examples below. A Makefile is also provided, so that
the examples can easily be compiled and run.
<p>


<h3>Contents of this document:</h3>

<p>
<ul type = none>
<li><a href = #sec_0>0 Scan-line-based and Tiled OpenEXR files</a>
<p>
<li><a href = #sec_1>1 Using the RGBA-only Interface for Scan-line-based Files</a>
<p>
    <ul type = none>
    <li><a href = #sec_1_1>1.1 Writing an RGBA Image File</a>
    <li><a href = #sec_1_2>1.2 Writing a Cropped Image</a>
    <li><a href = #sec_1_3>1.3 Storing Custom Attributes</a>
    <li><a href = #sec_1_4>1.4 Reading an RGBA Image File</a>
    <li><a href = #sec_1_5>1.5 Reading an RGBA Image File in Chunks</a>
    <li><a href = #sec_1_6>1.6 Reading Custom Attributes</a>
    <li><a href = #sec_1_7>1.7 Luminance/Chroma and Gray-Scale Images</a>
    </ul>
<p>
<li><a href = #sec_2>2 Using the General Interface for Scan-line-based Files</a>
<p>
    <ul type = none>
    <li><a href = #sec_2_1>2.1 Writing an Image File</a>
    <li><a href = #sec_2_2>2.2 Writing a Cropped Image</a>
    <li><a href = #sec_2_3>2.3 Reading an Image File</a>
    <li><a href = #sec_2_4>2.4 Interleaving Image Channels in the Frame Buffer</a>
    <li><a href = #sec_2_5>2.5 Which Channels are in a File?</a>
    </ul>
<p>
<li><a href="#sec_3">3 Tiles, Levels and Level Modes</a>
<p>
<li><a href="#sec_4">4 Using the RGBA-only Interface for Tiled Files</a>
<p>
    <ul type="none">
	<li><a href="#sec_4_1">4.1 Writing a Tiled RGBA Image File with One Resolution Level</a></li>
	<li><a href="#sec_4_2">4.2 Writing a Tiled RGBA Image File with Mipmap Levels</a></li>
	<li><a href="#sec_4_3">4.3 Writing a Tiled RGBA Image File with Ripmap Levels</a></li>
	<li><a href="#sec_4_4">4.3 Reading a Tiled RGBA Image File</a></li>
    </ul>
<p>
<li><a href="#sec_5">5 Using the General Interface for Tiled Files</a>
<p>
    <ul type="none">
	<li><a href="#sec_5_1">5.1 Writing a Tiled Image File</a></li>
	<li><a href="#sec_5_2">5.2 Reading a Tiled Image File</a></li>
    </ul>
<p>
<li><a href="#sec_6">6 Miscellaneous</a>
<p>
    <ul type="none">
	<li><a href="#sec_6_1">6.1 Is this an OpenEXR File?</a></li>
	<li><a href="#sec_6_2">6.2 Custom Low-Level File I/O</a></li>
	<li><a href="#sec_6_3">6.3 Preview Images</a></li>
	<li><a href="#sec_6_4">6.4 Environment Maps</a></li>
    </ul>

</ul>
<br>

<a name = sec_0><h3>0 Scan-line-based and Tiled OpenEXR files</h3></a>
<p>

In an OpenEXR file, pixel data can be stored either as scan lines or as tiles.
Files that store pixels as tiles can also store multiresolution images.
For each of the two storage formats (scan line or tile-based),
the IlmImf library supports two reading and writing interfaces:
The first, fully general, interface allows access to arbitrary
channels, and supports many different in-memory pixel data layouts.
The second interface is easier to use, but limits access to
16-bit (<code>HALF</code>) RGBA (red, green, blue, alpha) channels,
and provides fewer options for laying out pixels in memory.
<p>

The interfaces for reading and writing OpenEXR files are
implemented in the following eight C++ classes:
<p>

<table>
<tr>
    <th align = left></th>
    <th align = left>tiles</th>
    <th align = left>scan lines</th>
    <th align = left>scan lines and tiles</th>
</tr>
<tr>
    <th align = left>arbitrary channels</th>
    <td align = left><code>TiledInputFile</code></td>
    <td align = left></td>
    <td align = left><code>InputFile</code></td>
</tr>
<tr>
    <th align = left></th>
    <td align = left><code>TiledOutputFile</code></td>
    <td align = left><code>OutputFile</code></td>
    <td align = left></td>
</tr>
<tr>
    <th align = left>RGBA only</th>
    <td align = left><code>TiledRgbaInputFile</code></td>
    <td align = left></td>
    <td align = left><code>RgbaInputFile</code></td>
</tr>
<tr>
    <th></th>
    <td align = left><code>TiledRgbaOutputFile</code></td>
    <td align = left><code>RgbaOutputFile</code></td>
    <td align = left></td>
</tr>
</table>
<p>

The classes for reading scan-line-based images
(<code>InputFile</code> and <code>RgbaInputFile</code>)
can also be used to read tiled image files.  
This way, programs that do not need support for tiled
or multiresolution images can always use the rather straightforward
scan-line interfaces, without worrying about complications related
to tiling and multiple resolutions.
When a multiresolution file is read via a scan-line interface,
only the highest-resolution version of the image is accessible.
<p>


<a name = sec_1><h3>1 Using the RGBA-only Interface for Scan-line-based Files</h3></a>
<p>
<a name = sec_1_1><h4>1.1 Writing an RGBA Image File</h4></a>

<p>
Writing a simple RGBA image file is fairly straightforward:


<pre><code>
    void
    writeRgba1 (const char fileName[],
		const Rgba *pixels,
		int width,
		int height)
    {
	RgbaOutputFile file (fileName, width, height, WRITE_RGBA);	// 1
	file.setFrameBuffer (pixels, 1, width);				// 2
	file.writePixels (height);					// 3
    }
</code></pre>


Construction of an <code>RgbaOutputFile</code> object, in line 1,
creates an OpenEXR header, sets the header's attributes, opens the
file with the specified name, and stores the header in the file.
The header's display window and data window are both set to
<code>(0,&nbsp;0)&nbsp;-&nbsp;(width-1,&nbsp;height-1)</code>.
The channel list contains four channels, R, G, B, and A, of type
<code>HALF</code>.
<p>

Line 2 specifies how the pixel data are laid out in memory.  In our
example, the <code>pixels</code> pointer is assumed to point to the
beginning of an array of <code>width*height</code> pixels.
The pixels are represented as <code>Rgba</code> structs, which are
defined like this:


<pre><code>
    struct Rgba
    {
	half r;    // red
	half g;    // green
	half b;    // blue
	half a;    // alpha (opacity)
    };
</code></pre>


The elements of our array are arranged so that the pixels of each
scan line are contiguous in memory.
The&nbsp;<code>setFrameBuffer()</code> function takes three arguments,
<code>base</code>, <code>xStride</code>, and <code>ystride</code>.
To find the address of pixel <code>(x,y)</code>, the
<code>RgbaOutputFile</code> object computes
<pre>
    <code>base + x * xStride + y * yStride</code>.
</pre>

In this case, <code>base</code>, <code>xStride</code> and
<code>yStride</code> are set to <code>pixels</code>, <code>1</code>, and
<code>width</code>, respectively, indicating that pixel
<code>(x,y)</code> can be found at memory address
<code>
<pre>
    <code>pixels + 1 * x + width * y</code>.
</pre>
</code>
<p>

The call to <code>writePixels()</code>, in line 3, copies the image's
pixels from memory to the file.  The argument to <code>writePixels()</code>,
<code>height</code>, specifies how many scan lines worth of data are copied.
<p>

Finally, returning from function <code>writeRgba1()</code> destroys the local
<code>RgbaOutputFile</code> object, thereby closing the file.
<p>

Why do we have to tell the <code>writePixels()</code> function how many
scan lines we want to write?  Shouldn't the <code>RgbaOutputFile</code>
object be able to derive the number of scan lines from the data window?
The IlmImf library doesn't require writing all scan lines with a single
<code>writePixels()</code> call.  Many programs want to write scan lines
individually, or in small blocks. For example, rendering computer-generated
images can take a significant amount of time, and many rendering programs
want to store each scan line in the image file as soon as all of the pixels
for that scan line are available.  This way, users can look at a partial
image before rendering is finished.
The IlmImf library allows writing the scan lines in top-to-bottom or
bottom-to-top direction.  The direction is defined by the file header's
line order attribute (<code>INCREASING_Y</code> or <code>DECREASING_Y</code>).
By default, scan lines are written top to bottom (<code>INCREASING_Y</code>).
<p>

You may have noticed that in the example above, there are no explicit
checks to verify that writing the file actually succeeded.  If the IlmImf
library detects an error,  it throws a C++ exception instead of returning
a C-style error code.  With exceptions, error handling tends to be easier
to get right than with error return values.  For instance, a program that
calls our <code>writeRgba1()</code> function can handle all possible error
conditions with a single try/catch block:


<pre><code>
    try
    {
	writeRgba1 (fileName, pixels, width, height);
    }
    catch (const std::exception &amp;exc)
    {
	std::cerr &lt;&lt; exc.what() &lt;&lt; std::endl;
    }
</code></pre>


    
<p>
<a name = sec_1_2><h4>1.2 Writing a Cropped Image</h4></a>

<p>
Now we are going to store a cropped image in a file.  For this example,
we assume that we have a frame buffer that is large enough to hold an
image with <code>width</code> by <code>height</code> pixels, but only
part of the frame buffer contains valid data.
In the file's header, the size of the whole image is indicated by the
display window, <code>(0,&nbsp;0)&nbsp;-&nbsp;(width-1,&nbsp;height-1)</code>,
and the data window specifies the region for which valid pixel data exist.
Only the pixels in the data window are stored in the file.


<pre><code>
    void
    writeRgba2 (const char fileName[],
		const Rgba *pixels,
		int width,
		int height,
		const Box2i &amp;dataWindow)
    {
	Box2i displayWindow (V2i (0, 0), V2i (width - 1, height - 1));
	RgbaOutputFile file (fileName, displayWindow, dataWindow, WRITE_RGBA);
	file.setFrameBuffer (pixels, 1, width);
	file.writePixels (dataWindow.max.y - dataWindow.min.y + 1);
    }
</code></pre>


The code above is similar to that in section 1.1, where the whole image
was stored in the file.  Two things are different, however:  When the
<code>RgbaOutputFile</code> object is created, the data window and the
display window are explicitly specified, rather than being derived from
the image's width and height.
The number of scan lines stored in the file by <code>writePixels()</code>
is equal to the height of the data window, instead of the height of the
whole image.
Since we are using the default <code>INCREASING_Y</code> direction for
storing the scan lines in the file, <code>writePixels()</code> starts at
the top of the data window, at y coordinate <code>dataWindow.min.y</code>,
and proceeds toward the bottom, at y coordinate <code>dataWindow.max.y</code>.
<p>

Even though we are storing only part of the image in the file, the frame
buffer is still large enough to hold the whole image.  In order to save
memory, a smaller frame buffer could have been allocated, just big enough
to hold the contents of the data window.
Assuming that the pixels were still stored in contiguous scan lines, with
the <code>pixels</code> pointer pointing to the pixel at the upper left
corner of the data window, at coordinates
<code>(dataWindow.min.x,&nbsp;dataWindow.min.y)</code>, the arguments to
the <code>setFrameBuffer()</code> call would have to be to be changed as
follows:


<pre><code>
    int dwWidth = dataWindow.max.x - dataWindow.min.x + 1;

    file.setFrameBuffer
	(pixels - dataWindow.min.x - dataWindow.min.y * dwWidth, 1, dwWidth);
</code></pre>


With these settings, evaluation of

<pre>
    <code>base + x * xStride + y * yStride</code>
</pre>

for pixel (<code>dataWindow.min.x</code>,&nbsp;<code>dataWindow.min.y</code>)
produces

<pre>
<code>      pixels - dataWindow.min.x - dataWindow.min.y * dwWidth
	+ dataWindow.min.x * 1
	+ dataWindow.min.y * dwWidth

    = pixels -
	- dataWindow.min.x
	- dataWindow.min.y * (dataWindow.max.x - dataWindow.min.x + 1)
	+ dataWindow.min.x
	+ dataWindow.min.y * (dataWindow.max.x - dataWindow.min.x + 1)

    = pixels</code>,
</pre>

which is exactly what we want.  Similarly, calculating the addresses
for pixels <code>(dataWindow.min.x+1,&nbsp;dataWindow.min.y)</code>
and <code>(dataWindow.min.x,&nbsp;dataWindow.min.y+1)</code>
yields <code>pixels+1</code> and <code>pixels+dwWidth</code>, respectively.

    
<p>
<a name = sec_1_3><h4>1.3 Storing Custom Attributes</h4></a>

<p>
Now we want to store an image in a file, and we want to add two extra data
in the image file header: A string, called "comments", and a 4x4 matrix,
called "cameraTransform".


<pre><code>
    void
    writeRgba3 (const char fileName[],
		const Rgba *pixels,
		int width,
		int height,
		const char comments[],
		const M44f &amp;cameraTransform)
    {
	Header header (width, height);
	header.insert ("comments", StringAttribute (comments));
	header.insert ("cameraTransform", M44fAttribute (cameraTransform));

	RgbaOutputFile file (fileName, header, WRITE_RGBA);
	file.setFrameBuffer (pixels, 1, width);
	file.writePixels (height);
    }
</code></pre>


The <code>setFrameBuffer()</code> and <code>writePixels()</code> calls
are the same as in the previous examples, but construction of the
<code>RgbaOutputFile</code> object is different.
The constructors in the previous examples created a header on the fly,
and immediately stored it in the file.  Here we explicitly create a
header, and add our own attributes to it.
When we create the <code>RgbaOutputFile</code> object, we tell the
constructor to use our header instead of creating its own.
<p>

In order to make it easier to exchange data between programs written
by different people, the IlmImf library defines a set of
standard attributes for commonly used data,
such as colorimetric information, time and place where an
image was recorded, or the owner of an image file's content.
For the current list of standard attributes, see the header file
<code>ImfStandardAttributes.h</code>.
The list is expected to grow over time, as OpenEXR users identify
new types of data they would like to represent in a standard format.
If you need to store some piece of information in an OpenEXR file header,
it is probably a good idea to check if a suitable standard attribute
exists, before you define a new attribute.

    
<p>
<a name = sec_1_4><h4>1.4 Reading an RGBA Image File</h4></a>

<p>
Reading an RGBA image is almost as easy as writing one:


<pre><code>
    void
    readRgba1 (const char fileName[],
	       Array2D&lt;Rgba&gt; &amp;pixels,
	       int &amp;width,
	       int &amp;height)
    {
	RgbaInputFile file (fileName);
	Box2i dw = file.dataWindow();

	width  = dw.max.x - dw.min.x + 1;
	height = dw.max.y - dw.min.y + 1;
	pixels.resizeErase (height, width);

	file.setFrameBuffer (&amp;pixels[0][0] - dw.min.x - dw.min.y * width, 1, width);
	file.readPixels (dw.min.y, dw.max.y);
    }
</code></pre>


Constructing an <code>RgbaInputFile</code> object, passing the name of
the file to the constructor, opens the file and reads the file's header.
<p>

After asking the <code>RgbaInputFile</code> object for the file's data
window, we allocate a buffer for the pixels.  For convenience, we use the
IlmImf library's <code>Array2D</code> class template (the call to
<code>resizeErase()</code> does the actual allocation).
The number of scan lines in the buffer is equal to the height of the
data window, and the number of pixels per scan line is equal to the
width of the data window.  The pixels are represented as <code>Rgba</code>
structs.
<p>

Note that we ignore the display window; in a program that wanted to place
the pixels in the data window correctly in an overall image, the display
window would have to be taken into account.
<p>

Just as for writing a file, calling <code>setFrameBuffer()</code> tells
the <code>RgbaInputFile</code> object how to access individual pixels
in the buffer
(see also <a href = #sec_1_2>section 1.2, Writing a Cropped Image</a>).
<p>

Calling <code>readPixels()</code> copies the pixel data from the file
into the buffer.
If one or more of the R, G, B, and A channels are missing in the file,
the corresponding field in the pixels is filled with an appropriate
default value.  The default value for R, G and B is <code>0.0</code>,
or black; the default value for A is <code>1.0</code>, or opaque.
<p>

Finally, returning from function <code>readRgba1()</code> destroys the
local <code>RgbaInputFile</code> object, thereby closing the file.
<p>

Unlike the <code>RgbaOutputFile</code>'s </code>writePixels()</code>
method, <code>readPixels()</code> has two arguments.
Calling <code>readPixels(y1,y2)</code> copies the pixels
for all scan lines with y coordinates from <code>y1</code> to
<code>y2</code> into the frame buffer.  This allows access to the
the scan lines in any order.  The image can be read all at once,
one scan line at a time, or in small blocks of a few scan lines.
It is also possible to skip parts of the image.
<p>

Note that even though random access is possible, reading the scan lines
in the same order as they were written, is more efficient.  Random access
to the file requires seek operations, which tend to be slow.
Calling the RgbaInputFile's <code>lineOrder()</code> method returns the
order in which the scan lines in the file were written
(<code>INCREASING_Y</code> or <code>DECREASING_Y</code>).
If successive calls to readPixels() access the scan lines in the right
order, the IlmImf library reads the file as fast as possible, without
seek operations.
<p>


<p>
<a name = sec_1_5><h4>1.5 Reading an RGBA Image File in Chunks</h4></a>

<p>
The following shows how to read an RGBA image in blocks of
a few scan lines.  This is useful for programs that want to process
high-resolution images without allocating allocating enough memory
to hold the complete image.  Those programs typically read a few
scan lines worth of pixels into a memory buffer, process the pixels,
and store them in another file.  The buffer is then re-used for
the next set of scan lines.
Image operations like color-correction or compositing ("A over B")
are very easy to do incrementally this way.  With clever buffering
of a few extra scan lines, incremental versions of operations that
require access to neighboring pixels, like blurring or sharpening,
are also possible.


<pre><code>
    void
    readRgba2 (const char fileName[])
    {
	RgbaInputFile file (fileName);
	Box2i dw = file.dataWindow();

	int width  = dw.max.x - dw.min.x + 1;
	int height = dw.max.y - dw.min.y + 1;
	Array2D&lt;Rgba&gt; pixels (10, width);

	while (dw.min.y &lt;= dw.max.y)
	{
	    file.setFrameBuffer (&amp;pixels[0][0] - dw.min.x - dw.min.y * width,
				 1, width);

	    file.readPixels (dw.min.y, min (dw.min.y + 9, dw.max.y));
	    // processPixels (pixels)
	    
	    dw.min.y += 10;
	}
    }
</code></pre>


Again, we open the file and read the file header by constructing an
<code>RgbaInputFile</code> object.   Then we allocate a memory buffer
that is just large enough to hold ten complete scan lines.
We call <code>readPixels()</code> to copy the pixels from the file
into our buffer, ten scan lines at a time.
Since we want to re-use the buffer for every block of ten scan lines,
we have to call <code>setFramebuffer()</code> before each
<code>readPixels()</code> call, in order to associate memory address
<code>&amp;pixels[0][0]</code> first with pixel coordinates
<code>(dw.min.x,&nbsp;dw.min.y)</code>, then with
<code>(dw.min.x,&nbsp;dw.min.y+10)</code>,
<code>(dw.min.x,&nbsp;dw.min.y+20)</code> and so on.

    
<p>
<a name = sec_1_6><h4>1.6 Reading Custom Attributes</h4></a>

<p>
In section 1.3, we showed how to store custom attributes in the image file
header.  Here we show how to test whether a given file's header contains
particular attributes, and how to read those attributes' values.


<pre><code>
    void
    readHeader (const char fileName[])
    {
	RgbaInputFile file (fileName);

	const StringAttribute *comments =
	    file.header().findTypedAttribute &lt;StringAttribute&gt; ("comments");

	const M44fAttribute *cameraTransform = 
	    file.header().findTypedAttribute &lt;M44fAttribute&gt; ("cameraTransform");

	if (comments)
	    cout &lt;&lt; "comments\n   " &lt;&lt; comments-&gt;value() &lt;&lt; endl;

	if (cameraTransform)
	    cout &lt;&lt; "cameraTransform\n" &lt;&lt; cameraTransform-&gt;value() &lt;&lt; flush;
    }
</code></pre>


As usual, we open the file by constructing an <code>RgbaInputFile</code>
object.  Calling <code>findTypedAttribute&lt;T&gt;(n)</code> searches the
header for an attribute with type <code>T</code> and name <code>n</code>.
If a matching attribute is found, <code>findTypedAttribute()</code> returns
a pointer to the attribute.
If the header contains no attribute with name <code>n</code>, or if the
header contains an attribute with name <code>n</code>, but the attribute's
type is not <code>T</code>, <code>findAttribute()</code> returns
<code>0</code>.
Once we have pointers to the attributes we were looking for, we can
access their values by calling the attributes' <code>value()</code> methods.
<p>

In this example, we handle the possibility that the attributes we
want may not exist by explicitly checking for <code>0</code> pointers.
Sometimes it is more convenient to rely on exceptions instead.
Function <code>typedAttribute()</code>, a&nbsp;variation of
<code>findTypedAttribute()</code>, also searches the header for
an attribute with a given name and type, but if the attribute
in question does not exist, <code>typedAttribute()</code> throws
an exception rather than returning <code>0</code>.
<p>

Note that the pointers returned by <code>findTypedAttribute()</code>
point to data that are part of the <code>RgbaInputFile</code> object.
The pointers become invalid as soon as the <code>RgbaInputFile</code>
object is destroyed.  Therefore, the following will not work:


<pre><code>
    void
    readComments (const char fileName[], StringAttribute *&amp;comments)
    {
    	// error: comments pointer is invalid after this function returns
	RgbaInputFile file (fileName);
	comments = file.header().findTypedAttribute &lt;StringAttribute&gt; ("comments");
    }
</code></pre>


<code>readComments()</code> must copy the attribute's value before it returns;
for example, like this:


<pre><code>
    void
    readComments (const char fileName[], string &amp;comments)
    {

	RgbaInputFile file (fileName);
	comments = file.header().typedAttribute&lt;StringAttribute&gt;("comments").value();
    }
</code></pre>


<p>
<a name = sec_1_7><h4>1.7 Luminance/Chroma and Gray-Scale Images</h4></a>
<p>
Writing an RGBA image file usually preserves the pixels without losing
any data; saving an image file, and reading it back does not alter
the pixels' R, G, B and A values.
Most of the time, lossless data storage is exactly what we want,
but sometimes file space or transmission bandwidth are limited,
and we would like to reduce the size of our image files.
It is often acceptable if the numbers in the pixels change slightly,
as long as the image still looks just like the original.
<p>
The RGBA interface in the IlmImf library supports storing RGB data
in luminance/chroma format.  The R, G, and B channels are converted
into a luminance channel, Y, and two chroma channels, RY and BY.
The Y channel represents a pixel's brightness, and the two chroma
channels represent its color.
The human visual system's spatial resolution for color is much lower
than the spatial resolution for brightness.  This allows us to reduce
the horizontal and vertical resolution of the RY and BY channels by
a factor of two.  The visual appearance of the image doesn't change,
but the image occupies only half as much space, even before data
compression is applied.
(For every four pixels, we store four Y values, one RY value,
and one BY value, instead of four R, four G, and four B values.)
<p>
When opening a file for writing, a program can select how it
wants the pixels to be stored.  The constructors for class
<code>RgbaOutputFile</code> have an <code>rgbaChannels</code>
argument, which determines the set of channels in the file:
<p>

<table>
  <tr>
    <td valign="top">
    <code>WRITE_RGB</code></td>
    <td valign="top">
    red, gren, blue </td>
  </tr>
  <tr>
    <td valign="top">
    <code>WRITE_RGBA</code></td>
    <td valign="top">
    red, gren, blue, alpha </td>
  </tr>
  <tr>
    <td valign="top">
    <code>WRITE_YC</code></td>
    <td valign="top">
    luminance, chroma </td>
  </tr>
  <tr>
    <td valign="top">
    <code>WRITE_YCA</code></td>
    <td valign="top">
    luminance, chroma, alpha </td>
  </tr>
  <tr>
    <td valign="top">
    <code>WRITE_Y</code></td>
    <td valign="top">
    luminance only </td>
  </tr>
  <tr>
    <td valign="top">
    <code>WRITE_YA</code></td>
    <td valign="top">
    luminance, alpha </td>
  </tr>
</table>
<p>

<code>WRITE_Y</code> and <code>WRITE_YA</code> provide an efficient way
to store gray-scale images.  The chroma channels for a gray-scale image
contain only zeroes, so they can be omitted from the file.
<p>
When an image file is opened for reading, class <code>RgbaInputFile</code>
automatically detects luminance/chroma images, and converts the pixels
back to RGB format.
<p>
<a name = sec_2><h3>2 Using the General Interface for Scan-line-based Files</h3></a>

<p><a name = sec_2_1><h4>2.1 Writing an Image File</h4></a>

<p>
This example demonstrates how to write an OpenEXR image file with two channels:
One channel, of type <code>HALF</code>, is called G, and the other,
of type <code>FLOAT</code>, is called Z.
The size of the image is <code>width</code> by <code>height</code> pixels.
The data for the two channels are supplied in two separate
buffers, <code>gPixels</code> and <code>zPixels</code>.
Within each buffer, the pixels of each scan line are contiguous in memory.


<pre><code>
    void
    writeGZ1 (const char fileName[],
	      const half *gPixels,
	      const float *zPixels,
	      int width,
	      int height)
    {
	Header header (width, height);					  // 1
	header.channels().insert ("G", Channel (HALF));			  // 2
	header.channels().insert ("Z", Channel (FLOAT));		  // 3
    
	OutputFile file (fileName, header);				  // 4

	FrameBuffer frameBuffer;					  // 5

	frameBuffer.insert ("G",				// name   // 6
			    Slice (HALF,			// type	  // 7
				   (char *) gPixels,		// base	  // 8
				   sizeof (*gPixels) * 1,	// xStride// 9
				   sizeof (*gPixels) * width));	// yStride// 10

	frameBuffer.insert ("Z",				// name   // 11
			    Slice (FLOAT,			// type   // 12
				   (char *) zPixels,		// base   // 13
				   sizeof (*zPixels) * 1,	// xStride// 14
				   sizeof (*zPixels) * width));	// yStride// 15

	file.setFrameBuffer (frameBuffer);				  // 16
	file.writePixels (height);					  // 17
    }
</code></pre>


In line 1, an OpenEXR header is created, and the header's
display window and data window are both set to
<code>(0,&nbsp;0)&nbsp;-&nbsp;(width-1,&nbsp;height-1)</code>.
<p>

Lines 2 and 3 specify the names and types
of the image channels that will be stored in the file.
<p>

Constructing an <code>OutputFile</code> object, in line 4, opens the file with
the specified name, and stores the header in the file.
<p>

Lines 5 through 16 tell the <code>OutputFile</code> object how
the pixel data for the image channels are laid out in memory.
After constructing a <code>FrameBuffer</code> object, a <code>Slice</code>
is added for each of the image file's channels.
A&nbsp;<code>Slice</code> describes the memory layout of one channel.
The constructor for the <code>Slice</code> object takes four arguments,
<code>type</code>, <code>base</code>, <code>xStride</code>,
and <code>yStride</code>.
<code>type</code> specifies the pixel data type
(<code>HALF</code>, <code>FLOAT</code>, or <code>UINT</code>);
the other three arguments define the memory address of
pixel <code>(x,y)</code> as
<pre>
    <code>base + x * xStride + y * yStride</code>.
</pre>

Note that <code>base</code> is of type <code>char*</code>, and that offsets
from <code>base</code> are not implicitly multiplied by the size of an
individual pixel, as in the RGBA-only interface.
<code>xStride</code> and <code>yStride</code> must explictly
take the size of the pixels into account.
<p>

With the values specified in our example, the IlmImf library
computes the address of the G channel of pixel <code>(x,y)</code> like this:

<pre>
<code>    (half*)((char*)gPixels + x * sizeof(half) * 1 + y * sizeof(half) * width)
  = (half*)((char*)gPixels + x * 2 + y * 2 * width)</code>,
</pre>

The address of the Z channel of pixel <code>(x,y)</code> is

<pre>
<code>    (float*)((char*)zPixels + x * sizeof(float) * 1 + y * sizeof(float) * width)
  = (float*)((char*)zPixels + x * 4 + y * 4 * width)</code>.
</pre>

The <code>writePixels()</code> call in line 9 copies the image's pixels
from memory into the file.
As in the RGBA-only interface, the argument to <code>writePixels()</code>
specifies how many scan lines are copied into the file
(see <a href = #sec_1_1>section 1.1, Writing an RGBA Image File</a>).
<p>

If the image file contains a channel for which the <code>FrameBuffer</code>
object has no corresponding <code>Slice</code>, then the pixels for that
channel in the file are filled with zeroes.
If the <code>FrameBuffer</code> object contains a <code>Slice</code> for
which the file has no channel, then the <code>Slice</code> is ignored.
<p>

Returning from function <code>writeGZ1()</code> destroys the local
<code>OutputFile</code> object, and closes the file.

    
<p>
<a name = sec_2_2><h4>2.2 Writing a Cropped Image</h4></a>

<p>
Writing a cropped image using the general interface is analogous to
writing a cropped image using the RGBA-only interface, as shown in
<a href = #sec_1_2>section 1.2</a>:
In the file's header, the data window is set explicitly, instead of
being generated automatically from the image's width and height.
The number of scan lines that are stored in the file is equal to
the height of the data window, instead of the height of the entire image.
As in section 1.2, the example code below assumes that the memory
buffers for the pixels are large enough to hold <code>width</code>
by <code>height</code> pixels, but only the region that corresponds
to the data window will be stored in the file.
For smaller memory buffers with room only for
the pixels in the data window, the <code>base</code>, <code>xStride</code>
and <code>yStride</code> arguments for the <code>FrameBuffer</code>
object's slices would have to be adjusted accordingly
(again, see section 1.2).


<pre><code>
    void
    writeGZ2 (const char fileName[],
	      const half *gPixels,
	      const float *zPixels,
	      int width,
	      int height,
	      const Box2i &amp;dataWindow)
    {
	Header header (width, height);
	header.dataWindow() = dataWindow;
	header.channels().insert ("G", Channel (HALF));
	header.channels().insert ("Z", Channel (FLOAT));

	OutputFile file (fileName, header);

	FrameBuffer frameBuffer;

	frameBuffer.insert ("G",				// name
			    Slice (HALF,			// type
				   (char *) gPixels,		// base
				   sizeof (*gPixels) * 1,	// xStride
				   sizeof (*gPixels) * width));	// yStride

	frameBuffer.insert ("Z",				// name
			    Slice (FLOAT,			// type
				   (char *) zPixels,		// base
				   sizeof (*zPixels) * 1,	// xStride
				   sizeof (*zPixels) * width));	// yStride

	file.setFrameBuffer (frameBuffer);
	file.writePixels (dataWindow.max.y - dataWindow.min.y + 1);
    }
</code></pre>


<p>
<a name = sec_2_3><h4>2.3 Reading an Image File</h4></a>

<p>
In this example, we read an OpenEXR image file, using the
IlmImf library's general interface.  We assume that the file
contains two channels, R, and G, of type <code>HALF</code>, and one channel,
Z, of type <code>FLOAT</code>.  If one of those channels is not present in
the image file, the corresponding memory buffer for the pixels
will be filled with an appropriate default value.


<pre><code>
    void
    readGZ1 (const char fileName[],
	     Array2D&lt;half&gt; &amp;rPixels,
	     Array2D&lt;half&gt; &amp;gPixels,
	     Array2D&lt;float&gt; &amp;zPixels,
	     int &amp;width, int &amp;height)
    {
	InputFile file (fileName);

	Box2i dw = file.header().dataWindow();
	width  = dw.max.x - dw.min.x + 1;
	height = dw.max.y - dw.min.y + 1;

	rPixels.resizeErase (height, width);
	gPixels.resizeErase (height, width);
	zPixels.resizeErase (height, width);

	FrameBuffer frameBuffer;

	frameBuffer.insert ("R",				  // name
			    Slice (HALF,			  // type
				   (char *) (&amp;rPixels[0][0] -	  // base
					     dw.min.x -
					     dw.min.y * width),
				   sizeof (rPixels[0][0]) * 1,	  // xStride
				   sizeof (rPixels[0][0]) * width,// yStride
				   1, 1,			  // x/y sampling
				   0.0));			  // fillValue

	frameBuffer.insert ("G",				  // name
			    Slice (HALF,			  // type
				   (char *) (&amp;gPixels[0][0] -	  // base
					     dw.min.x -
					     dw.min.y * width),
				   sizeof (gPixels[0][0]) * 1,	  // xStride
				   sizeof (gPixels[0][0]) * width,// yStride
				   1, 1,			  // x/y sampling
				   0.0));			  // fillValue

	frameBuffer.insert ("Z",				  // name
			    Slice (FLOAT,			  // type
				   (char *) (&amp;zPixels[0][0] -	  // base
					     dw.min.x -
					     dw.min.y * width),
				   sizeof (zPixels[0][0]) * 1,	  // xStride
				   sizeof (zPixels[0][0]) * width,// yStride
				   1, 1,			  // x/y sampling
				   FLT_MAX));			  // fillValue

	file.setFrameBuffer (frameBuffer);
	file.readPixels (dw.min.y, dw.max.y);
    }
</code></pre>


First, we open the file with the specified name,
by constructing an <code>InputFile</code> object.
<p>

Using the <code>Array2D</code> class template, we allocate memory buffers for
the image's R, G and Z channels.  The buffers are big enough to
hold all pixels in the file's data window.
<p>

Next, we create a <code>FrameBuffer</code> object, which describes our
buffers to the IlmImf library.  For each image channel, we
add a slice to the FrameBuffer.
<p>

As usual, the slice's <code>type</code>, <code>xStride</code>,
and <code>yStride</code> describe the corresponding buffer's layout.
For the R channel, pixel <code>(dw.min.x,&nbsp;dw.min.y)</code> is at address
<code>&amp;rPixels[0][0]</code>.
By setting the <code>type</code>, <code>xStride</code> and <code>yStride</code>
of the corresponding <code>Slice</code> object as shown above, evaluating

<pre>
    <code>base + x * xStride + y * yStride</code>
</pre>

for pixel <code>(dw.min.x,&nbsp;dw.min.y)</code> produces

<pre>
<code>      (char*)(&amp;rPixels[0][0] - dw.min.x - dw.min.y * width)
       + dw.min.x * sizeof (rPixels[0][0]) * 1
       + dw.min.y * sizeof (rPixels[0][0]) * width

    = (char*)&amp;rPixels[0][0]
       - dw.min.x * sizeof (rPixels[0][0])
       - dw.min.y * sizeof (rPixels[0][0]) * width
       + dw.min.x * sizeof (rPixels[0][0])
       + dw.min.y * sizeof (rPixels[0][0]) * width

    = &amp;rPixels[0][0]</code>
</pre>

The address calculations for pixels
<code>(dw.min.x+1,&nbsp;dw.min.y)</code> and
<code>(dw.min.x,&nbsp;dw.min.y+1)</code> produce
<code>&amp;rPixels[0][0]+1</code> and
<code>&amp;rPixels[0][0]+width</code>, which is equivalent to
<code>&amp;rPixels[0][1]</code> and
<code>&amp;rPixels[1][0]</code>.
<p>

Each <code>Slice</code> has a <code>fillValue</code>.
If the image file does not contain
an image channel for the <code>Slice</code>, then the corresponding memory
buffer will be filled with the <code>fillValue</code>.
<p>

The <code>Slice's</code> remaining two parameters,
<code>xSampling</code> and <code>ySampling</code>
are used for images where some of the channels are subsampled,
for instance, the RY and BY channels in luminance/chroma images.
(see <a href = #sec_1_7>section 1.7, Luminance/Chroma and Gray-scale Images</a>).
Unless an image contains subsampled
channels, <code>xSampling</code> and <code>ySampling</code>
should always be set to 1.  
For details, see header files ImfFrameBuffer.h and ImfChannelList.h.
<p>

After describing our memory buffers' layout, we call
<code>readPixels()</code> to copy the pixel data from
the file into the buffers.
Just as with the RGBA-only interface, <code>readPixels()</code>
allows random-access to the scan lines in the file
(see <a href = #sec_1_4>section 1.4, Reading an RGBA Image File</a>).

    
<p>
<a name = sec_2_4><h4>2.4 Interleaving Image Channels in the Frame Buffer</h4></a>

<p>
Here is a variation of the previous example.  We are reading
an image file, but instead of storing each image channel in a separate
memory buffer, we interleave the channels in a single buffer.
The buffer is an array of structs, which are defined like this:


<pre><code>
    typedef struct GZ
    {
	half  g;
	float z;
    };
</code></pre>


The code to read the file is almost the same as before;
aside from reading only two instead of three channels, the only
difference is how <code>base</code>, <code>xStride</code> and
<code>yStride</code> for the <code>Slice</code>s in the
<code>FrameBuffer</code> object are computed:


<pre><code>
    void
    readGZ2 (const char fileName[],
	     Array2D&lt;GZ&gt; &amp;pixels,
	     int &amp;width, int &amp;height)
    {
	InputFile file (fileName);

	Box2i dw = file.header().dataWindow();
	width  = dw.max.x - dw.min.x + 1;
	height = dw.max.y - dw.min.y + 1;
	int dx = dw.min.x;
	int dy = dw.min.y;

	pixels.resizeErase (height, width);

	FrameBuffer frameBuffer;

	frameBuffer.insert ("G",
			    Slice (HALF,
				   (char *) &amp;pixels[-dy][-dx].g,
				    sizeof (pixels[0][0]) * 1,
				    sizeof (pixels[0][0]) * width));

	frameBuffer.insert ("Z",
			    Slice (FLOAT,
				   (char *) &amp;pixels[-dy][-dx].z,
				    sizeof (pixels[0][0]) * 1,
				    sizeof (pixels[0][0]) * width));

	file.setFrameBuffer (frameBuffer);
	file.readPixels (dw.min.y, dw.max.y);
    }
</code></pre>


<p>
<a name = sec_2_5><h4>2.5 Which Channels are in a File?</h4></a>

<p>
In functions <code>readGZ1()</code> and <code>readGZ2()</code>, above,
we simply assumed that the files we were trying to read contained a
certain set of channels.
We relied on the IlmImf library to do "something reasonable" in case
our assumption was not true.
Sometimes we want to know exactly what channels are in an image file
before reading any pixels, so that we can do what we think is appropriate.
<p>

The file's header contains the file's channel list.
Using STL-style iterators, we can iterate over the channels:


<pre><code>
    const ChannelList &amp;channels = file.header().channels();

    for (ChannelList::ConstIterator i = channels.begin(); i != channels.end(); ++i)
    {
	const Channel &amp;channel = i-&gt;second;
	// ...
    }
</code></pre>


Channels can also be accessed by name, either with the
<code>[]</code> operator, or with the <code>findChannel()</code>
function:


<pre><code>
    const ChannelList &amp;channels = file.header().channels();
    const Channel &amp;channel = channelList["G"];
    const Channel *channelPtr = channelList.findChannel("G");
</code></pre>


The difference between the <code>[]</code> operator and
<code>findChannel()</code> function is how errors are handled:
If the channel in question is not present,
<code>findChannel()</code> returns <code>0</code>;
the <code>[]</code> operator throws an exception.


<p>
<a name="sec_3"><h3>3 Tiles, Levels and Level Modes</h3></a>
<p>

A single tiled OpenEXR file can hold multiple versions of an image,
each with a different resolution.  Each version is called a "level".
A tiled file's "level mode" defines how many levels are stored in the file.
There are three different level modes:

<table>
  <tr>
    <th align="left">
    name
    </th>
    <th align="left">
    description
    </th>
  </tr>
  <tr>
    <td valign="top">
    <code>ONE_LEVEL</code></td>
    <td valign="top">
	The file contains only a single, full-resolution level.
	A <code>ONE_LEVEL</code> image file is equivalent to a
	scan-line-based file;
	the only difference is that the pixels are accessed by tile
	instead of by scan line.
    </td>
  </tr>
  <tr>
    <td valign="top">
    <code>MIPMAP_LEVELS</code></td>
    <td valign="top">
	The file contains multiple levels.
	The first level holds the image at full resolution.
	Each successive level is half the resolution of the
	previous level in x and y direction.
	The last level contains only a single pixel.
	<code>MIPMAP_LEVELS</code> files are used for
	texture-mapping and similar applications.
    </td>
  </tr>
  <tr>
    <td valign="top">
    <code>RIPMAP_LEVELS</code></td>
    <td valign="top">
	Like <code>MIPMAP_LEVELS</code>, but with more levels.
	The levels include all combinations of reducing the
	resolution of the image by powers of two independently
	in x and y direction.  Used for texture mapping, like
	<code>MIPMAP_LEVELS</code>; the additional levels
	in a <code>RIPMAP_LEVELS</code> file can help to
	accelerate anisotropic filtering during texture lookups.
    </td>
  </tr>
</table>
<p>

In MIPMAP_LEVELS and RIPMAP_LEVELS mode, the size (width or height)
of each level is computed by halving the size of the level with the next
higher resolution.  If the size of the higher-resolution level is odd,
then the size of the lower-resolution level must be rounded up or down
in order to avoid arriving at a non-integer width or height.
The rounding direction is determined by the file's "level size rounding mode".
<p>

Within each level, the pixels of the image are stored in
a two-dimensional array of tiles.   The tiles in an OpenEXR file
can be any rectangular shape, but all tiles in a file have the
same size.  This means that lower-resolution levels contain fewer,
rather than smaller, tiles.
<p>

An OpenEXR file's level mode and rounding mode, and the size of the tiles
are stored in an attribute in the file header.  The value of this
attribute is a <code>TileDescription</code> object:

<pre><code>
    enum LevelMode
    {
	ONE_LEVEL,
	MIPMAP_LEVELS,
	RIPMAP_LEVELS
    };

    enum LevelRoundingMode
    {
	ROUND_DOWN,
	ROUND_UP
    };

    class TileDescription
    {
      public:

	unsigned int	  xSize;	// size of a tile in the x dimension
	unsigned int	  ySize;	// size of a tile in the y dimension
	LevelMode	  mode;
	LevelRoundingMode roundingMode;

	... 				// (methods omitted)
    };
</code></pre>


<p>
<a name="sec_4"><h3>4 Using the RGBA-only Interface for Tiled Files</h3></a>
<p>
<a name="sec_4_1"><h4>4.1 Writing a Tiled RGBA Image File with One Resolution Level</h4></a>
<p>
Writing a tiled RGBA image with a single level is easy:

<pre><code>
    void
    writeTiledRgbaONE1 (const char fileName[],
			const Rgba *pixels,
			int width, int height,
			int tileWidth, int tileHeight)
    {
	TiledRgbaOutputFile out (fileName,
				 width, height,		// image size
				 tileWidth, tileHeight,	// tile size
				 ONE_LEVEL,		// level mode
				 ROUND_DOWN,		// rounding mode
				 WRITE_RGBA);		// channels in file // 1

	out.setFrameBuffer (&amp;pixels[0][0], 1, width);                       // 2

	for (int tileY = 0; tileY &lt; out.numYTiles (); ++tileY)              // 3
	    for (int tileX = 0; tileX &lt; out.numXTiles (); ++tileX)          // 4
		out.writeTile (tileX, tileY);                               // 5
    }
</code></pre>


<p>
Opening the file, and defining the pixel data layout in memory
are done in almost the same way as for scan-line-based files:
<p>
Construction of the <code>TiledRgbaOutputFile</code> object, in line 1,
creates an OpenEXR header, sets the header's attributes, opens the file
with the specified name, and stores the header in the file.
The header's display window and data window are both set to
<code>(0, 0) - (width-1, height-1)</code>.
The size of each tile in the file will be 
<code>tileWidth</code> by <code>tileHeight</code> pixels.
The channel list contains four channels, R, G, B, and A,
of type <code>HALF</code>.

<p>
Line 2 specifies how the pixel data are laid out in memory.
The arithmetic involved in calculating the memory address of
a specific pixel is the same as for the scan-line-based
interface (see <a href = #sec_1_1>section 1.1</a>).
We assume that the <code>pixels</code> pointer points to an array
of <code>width*height</code> pixels, which contains the entire image.

<p>
Lines 3 and 4 loop over all tiles within the image.
The <code>TiledRgbaOutputFile</code>'s <code>numXTiles()</code> method
returns the number of tiles in the x direction,
and similarly, the <code>numYTiles()</code> method
returns the number of tiles in the y dimension.
During these loops, line 5 writes out each tile in the image.

<p>
This simple method works well when enough memory is available
to allocate a frame buffer for the entire image.
When allocating a frame buffer for the whole image
is not desirable, for example, because the image is
very large, a smaller frame buffer can be used.
Even a frame buffer that can hold only a single tile is sufficient,
as demonstrated in the following example:

<pre><code>
    void
    writeTiledRgbaONE2 (const char fileName[],
			int width, int height,
			int tileWidth, int tileHeight)
    {
	TiledRgbaOutputFile out (fileName,
				 width, height,		// image size
				 tileWidth, tileHeight,	// tile size
				 ONE_LEVEL,		// level mode
				 ROUND_DOWN,		// rounding mode
				 WRITE_RGBA);		// channels in file // 1

	Array2D&lt;Rgba&gt; pixels (tileHeight, tileWidth);			    // 2

	for (int tileY = 0; tileY &lt; out.numYTiles (); ++tileY)		    // 3
	{
	    for (int tileX = 0; tileX &lt; out.numXTiles (); ++tileX)	    // 4
	    {
		Box2i range = out.dataWindowForTile (tileX, tileY);         // 5

		generatePixels (pixels, width, height, range);		    // 6

		out.setFrameBuffer (&amp;pixels[-range.min.y][-range.min.x],
				    1,		// xStride
				    tileWidth);	// yStride		    // 7

		out.writeTile (tileX, tileY);				    // 8
	    }
	}
    }
</code></pre>

<p>
In line 2 we allocate a <code>pixels</code> array with
<code>tileWidth*tileHeight</code> elements, which is just enough for one tile.
Line 5 computes the data window range for each tile, that is,
the set of pixel coordinates covered by the tile.
The <code>generatePixels()</code> function, in line 6, fills the
<code>pixels</code> array with one tile's worth of image data.
The same <code>pixels</code> array is reused for all tiles.
We have to call <code>setFrameBuffer()</code>, in line 7, before
writing each tile so that the pixels in the array are accessed
properly in the <code>writeTile()</code> call in line 8.
Again, the address arithmetic to access the pixels, is the same
as for scan-line-based files.  The values for the
<code>base</code>, <code>xStride</code>, and <code>yStride</code>
arguments to the <code>setFrameBuffer()</code> call must be chosen
so that evaluating the expression

<pre>
    <code>base + x * xStride + y * yStride</code>
</pre>

produces the address of the pixel with coordinates <code>(x,y)</code>.
<p>

<a name="sec_4_2"><h4>4.2 Writing a Tiled RGBA Image File with Mipmap Levels</h4></a>
<p>
In order to store a multiresolution image in a file,
we can allocate a frame buffer large enough for the highest-resolution
level, (0,0), and reuse it for all levels:

<pre><code>
    void
    writeTiledRgbaMIP1 (const char fileName[],
			int width, int height,
			int tileWidth, int tileHeight)
    {
	TiledRgbaOutputFile out (fileName,
				 width, height,
				 tileWidth, tileHeight,
				 MIPMAP_LEVELS,	
				 ROUND_DOWN,
				 WRITE_RGBA);					// 1

	Array2D&lt;Rgba&gt; pixels (height, width);					// 2
	out.setFrameBuffer (&amp;pixels[0][0], 1, width);				// 3

	for (int level = 0; level &lt; out.numLevels (); ++level)			// 4
	{
	    generatePixels (pixels, width, height, level);			// 5

	    for (int tileY = 0; tileY &lt; out.numYTiles (level); ++tileY)		// 6
		for (int tileX = 0; tileX &lt; out.numXTiles (level); ++tileX)	// 7
		    out.writeTile (tileX, tileY, level);			// 8
	}
    }
</code></pre>

<p>
The main difference here is the use of <code>MIPMAP_LEVELS</code>
in line 1 for the <code>TiledRgbaOutputFile</code> constructor.
This signifies that the file will contain multiple levels,
each level being a factor of 2 smaller in both dimensions than
the previous level.
Mipmap images contain n levels, with level numbers
<pre>
    (0,0), (1,1), ... (n-1,n-1),
</pre>
where
<pre>
    n = floor (log (max (width, height)) / log (2)) + 1
</pre>
if the level size rounding mode is ROUND_DOWN, or
<pre>
    n = ceil (log (max (width, height)) / log (2)) + 1
</pre>
if the level size rounding mode is ROUND_UP.
Note that even though level numbers are pairs of integers, (lx,ly),
only levels where lx equals ly are used in <code>MIPMAP_LEVELS</code> files.
<p>

Line 2 allocates a <code>pixels</code> array with
<code>width</code> by <code>height</code> pixels,
big enough to hold the highest-resolution level.
<p>

In addition to looping over all tiles (lines 6 and 7),
we must loop over all levels in the image (line 4).
<code>numLevels()</code> returns the number of levels, n,
in our mipmapped image.
Since the tile sizes remain the same in all levels,
the number of tiles in both dimensions varies between levels.
<code>numXTiles()</code> and <code>numYTiles()</code>
take a level number as an optional argument,
and return the number of tiles in the x or y direction
for the corresponding level.
Line 5 fills the <code>pixels</code> array with appropriate
data for each level.

<p>
As with <code>ONE_LEVEL</code> images, we can choose to only allocate a
frame buffer for a single tile and reuse it for all tiles in the image:

<pre><code>
    void
    writeTiledRgbaMIP2 (const char fileName[],
			int width, int height,
			int tileWidth, int tileHeight)
    {
	TiledRgbaOutputFile out (fileName,
				 width, height,
				 tileWidth, tileHeight,
				 MIPMAP_LEVELS,
				 ROUND_DOWN,
				 WRITE_RGBA);

	Array2D&lt;Rgba&gt; pixels (tileHeight, tileWidth);

	for (int level = 0; level &lt; out.numLevels (); ++level)
	{
	    for (int tileY = 0; tileY &lt; out.numYTiles (level); ++tileY)
	    {
		for (int tileX = 0; tileX &lt; out.numXTiles (level); ++tileX)
		{
		    Box2i range = out.dataWindowForTile (tileX, tileY, level);

		    generatePixels (pixels, width, height, range, level);

		    out.setFrameBuffer (&amp;pixels[-range.min.y][-range.min.x],
					1,		// xStride
					tileWidth);	// yStride

		    out.writeTile (tileX, tileY, level);
		}
	    }
	}
    }
</code></pre>

<p>
The structure of this code is the same as for writing a <code>ONE_LEVEL</code>
image using a tile-sized frame buffer, but we have to loop over more tiles.
Also, <code>dataWindowForTile()</code> takes an additional <code>level</code>
argument to determine the pixel range for the tile at the specified level.


<p>
<a name="sec_4_3"><h4>4.3 Writing a Tiled RGBA Image File with Ripmap Levels</h4></a>
<p>
The ripmap level mode allows for storing all combinations of reducing
the resolution of the image by powers of two independently in both dimensions.
Ripmap files contains nx*ny levels, with level numbers:
<pre>
    (0, 0),   (1, 0),   ... (nx-1, 0),
    (0, 1),   (1, 1),   ... (nx-1, 1),
     ...
    (0,ny-1), (1,ny-1), ... (nx-1,ny-1)
</pre>
where
<pre>
    nx = floor (log (width) / log (2)) + 1
    ny = floor (log (height) / log (2)) + 1
</pre>
if the level size rounding mode is ROUND_DOWN, or
<pre>
    nx = ceil (log (width) / log (2)) + 1
    ny = ceil (log (height) / log (2)) + 1
</pre>
if the level size rounding mode is ROUND_UP.
<p>

With a frame buffer that is large enough to hold level (0,0),
we can write a ripmap file like this:

<pre><code>
    void
    writeTiledRgbaRIP1 (const char fileName[],
			int width, int height,
			int tileWidth, int tileHeight)
    {
	TiledRgbaOutputFile out (fileName,
				 width, height,
				 tileWidth, tileHeight,
				 RIPMAP_LEVELS,
				 ROUND_DOWN,
				 WRITE_RGBA);

	Array2D&lt;Rgba&gt; pixels (height, width);
	out.setFrameBuffer (&amp;pixels[0][0], 1, width);

	for (int yLevel = 0; yLevel &lt; out.numYLevels (); ++yLevel)
	{
	    for (int xLevel = 0; xLevel &lt; out.numXLevels (); ++xLevel)
	    {
		generatePixels (pixels, width, height, xLevel, yLevel);

		for (int tileY = 0; tileY &lt; out.numYTiles (yLevel); ++tileY)
		    for (int tileX = 0; tileX &lt; out.numXTiles (xLevel); ++tileX)
			out.writeTile (tileX, tileY, xLevel, yLevel);
	    }
	}
    }
</code></pre>

<p>
As for <code>ONE_LEVEL</code> and <code>MIPMAP_LEVELS</code> files,
the frame buffer doesn't have to be large enough to hold a whole level.
Any frame buffer big enough to hold at least a single tile will work.

<p>
<a name="sec_4_4"><h4>4.4 Reading a Tiled RGBA Image File</h4></a>
<p>
Reading a tiled RGBA image file is done similarly to writing one:

<pre><code>
    void
    readTiledRgba1 (const char fileName[],
		    Array2D&lt;Rgba&gt; &amp;pixels,
		    int &amp;width,
		    int &amp;height)
    {
	TiledRgbaInputFile in (fileName);
	Box2i dw = in.dataWindow();

	width  = dw.max.x - dw.min.x + 1;
	height = dw.max.y - dw.min.y + 1;
	int dx = dw.min.x;
	int dy = dw.min.y;

	pixels.resizeErase (height, width);

	in.setFrameBuffer (&amp;pixels[-dy][-dx], 1, width);

	for (int tileY = 0; tileY &lt; in.numYTiles(); ++tileY)
	    for (int tileX = 0; tileX &lt; in.numXTiles(); ++tileX)
		in.readTile (tileX, tileY);
    }
</code></pre>

First we need to create a <code>TiledRgbaInputFile</code> object
for the given file name.
Then we retrieve information about the data window in order
to create an appropriately sized frame buffer,
in this case large enough to hold the whole image at level (0,0).
After we set the frame buffer, we iterate over the tiles we
are interested in, and read them from the file.
<p>

This example only reads the highest-resolution level of the image.
It can be extended to read all levels, for multiresolution images,
by also iterating over all levels within the image,
analogous to the examples in sections
<a href = #sec_4_2>section 4.2</a> and <a href = #sec_4_3>4.3</a>.


<p>
<a name = sec_5><h3>5 Using the General Interface for Tiled Files</h3></a>
<p>
<a name = sec_5_1><h4>5.1 Writing a Tiled Image File</h4></a>

<p>
This example is a variation of the one in <a href = #sec_2_1>section 2.1</a>.
We are writing a <code>ONE_LEVEL</code> image file
with two channels, G, and Z,
of type <code>HALF</code>, and <code>FLOAT</code> respectively,
but here the file is tiled instead of scan-line-based:
<p>

<pre><code>
    void
    writeTiled1 (const char fileName[],
		 Array2D&lt;GZ&gt; &amp;pixels,
		 int width, int height,
		 int tileWidth, int tileHeight)
    {
	Header header (width, height);						// 1
	header.channels().insert ("G", Channel (HALF));				// 2
	header.channels().insert ("Z", Channel (FLOAT));			// 3

	header.setTileDescription
	    (TileDescription (tileWidth, tileHeight, ONE_LEVEL));		// 4
	
	TiledOutputFile out (fileName, header);					// 5

	FrameBuffer frameBuffer;						// 6

	frameBuffer.insert ("G",				     // name	// 7
			    Slice (HALF,			     // type	// 8
				   (char *) &amp;pixels[0][0].g,	     // base	// 9
				    sizeof (pixels[0][0]) * 1,	     // xStride	// 10
				    sizeof (pixels[0][0]) * width)); // yStride	// 11

	frameBuffer.insert ("Z",				     // name	// 12
			    Slice (FLOAT,			     // type	// 13
				   (char *) &amp;pixels[0][0].z,	     // base	// 14
				    sizeof (pixels[0][0]) * 1,	     // xStride	// 15
				    sizeof (pixels[0][0]) * width)); // yStride	// 16

	out.setFrameBuffer (frameBuffer);					// 17

	for (int tileY = 0; tileY &lt; out.numYTiles (); ++tileY)			// 18
	    for (int tileX = 0; tileX &lt; out.numXTiles (); ++tileX)		// 19
		out.writeTile (tileX, tileY);					// 20
    }
</code></pre>

As one would expect, the code here is very similar to the code in
<a href = #sec_2_1>section 2.1</a>.
The file's header is created in line 1, while
lines 2 and 3 specify the names and types of the image channels
that will be stored in the file.
An important addition is line 4,
where we define the size of the tiles, and the level mode.
In this example we use <code>ONE_LEVEL</code> for simplicity.
Line 5 opens the file and writes the header.
Lines 6 through 17 tell the <code>TiledOutputFile</code>
object the location and layout of the pixel data for each channel.
Finally, lines 18 through 20 loop over all tiles in the image,
and write out each tile.


<p>
<a name="sec_5_2"><h4>5.2 Reading a Tiled Image File</h4></a>
<p>

Reading a tiled file with the general interface is virtually identical
to reading a scan-line-based file, as shown in
<a href = #sec_2_4>section 2.4</a>;
only the last three lines are different:
Instead of reading all scan lines at once
with a single function call,
here we must iterate over all tiles we want to read.
<p>

<pre><code>
    void
    readTiled1 (const char fileName[],
		Array2D&lt;GZ&gt; &amp;pixels,
		int &amp;width, int &amp;height)
    {
	TiledInputFile in (fileName);

	Box2i dw = in.header().dataWindow();
	width  = dw.max.x - dw.min.x + 1;
	height = dw.max.y - dw.min.y + 1;
	int dx = dw.min.x;
	int dy = dw.min.y;

	pixels.resizeErase (height, width);

	FrameBuffer frameBuffer;

	frameBuffer.insert ("G",
			    Slice (HALF,
				   (char *) &amp;pixels[-dy][-dx].g,
				    sizeof (pixels[0][0]) * 1,
				    sizeof (pixels[0][0]) * width));

	frameBuffer.insert ("Z",
			    Slice (FLOAT,
				   (char *) &amp;pixels[-dy][-dx].z,
				    sizeof (pixels[0][0]) * 1,
				    sizeof (pixels[0][0]) * width));

	in.setFrameBuffer (frameBuffer);

	for (int tileY = 0; tileY &lt; in.numYTiles(); ++tileY)
	    for (int tileX = 0; tileX &lt; in.numXTiles(); ++tileX)
		in.readTile (tileX, tileY);
    }
</code></pre>

In this example we assume that the file
we want to read contains two channels, G and Z, of type
<code>HALF</code> and <code>FLOAT</code> respectively.
If the file contains other channels, we ignore them.
We only read the highest-resolution level of the image.
If the input file contains more levels
(<code>MIPMAP_LEVELS</code> or <code>MIPMAP_LEVELS</code>),
we can access the extra levels by calling a four-argument
version of the <code>readTile()</code> function:

<pre>
    <code>in.readTile (tileX, tileY, levelX, levelY);</code>
</pre>
<p>

<p>
<a name = sec_6><h3>6 Miscellaneous</h3></a>
<p>
<a name = sec_6_1><h4>6.1 Is this an OpenEXR File?</h4></a>
<p>
Sometimes we want to test quickly if a given file is an OpenEXR file.
This can be done by looking at the beginning of the file:
The first four bytes of every OpenEXR file contain a 32-bit
integer "magic number", 20000630, in little-endian byte order.
After reading a file's first four bytes via any of the operating system's
standard file I/O mechanisms, we can compare them with the
magic number, either by calling function <code>isImfMagic()</code>,
or by explicitly testing if the bytes contain the values
<code>0x76</code>, <code>0x2f</code>, <code>0x31</code>,
and <code>0x01</code>.
<p>
Given a file name, the following function returns true if the
corresponding file exists, is readable, and contains an OpenEXR image:
<p>

<pre><code>
    bool
    isOpenExrFile (const char fileName[])
    {
	std::ifstream f (fileName, std::ios_base::binary);

	char bytes[4];
	f.read (bytes, sizeof (bytes));

	return !!f &amp;&amp; Imf::isImfMagic (bytes);
    }
</code></pre>
<p>

<a name = sec_6_2><h4>6.2 Custom Low-Level File I/O</h4></a>
<p>
In all of the previous file reading and writing examples, we were
given a file name, and we relied on the constructors for our input
file or output file objects to open the file.
In some contexts, for example in a plugin for an
existing application program, we may have to read from or write to
a file that has already been opened.  The representation of the open
file as a C or C++ data type depends on the application program and
on the operating system.
<p>
At its lowest level, the IlmImf library performs file I/O via objects
of type <code>IStream</code> and <code>OStream</code>.
<code>IStream</code> and <code>OStream</code> are abstract base
classes.  The IlmImf library contains two derived classes,
<code>StdIstream</code> and </code>StdOstream</code>, that implement
reading from <code>std::ifstream</code> and writing
to <code>std::ofstream</code> objects.
An application program can implement alternative file I/O mechanisms
by deriving its own classes from <code>Istream</code> and <code>Ostream</code>.
This way, OpenEXR images can be stored in arbitrary file-like objects,
as long as it is possible to support read, write, seek and tell
operations with semantics similar to the corresponding
<code>std::ifstream</code> and <code>std::ofstream</code> methods.
<p>
For example, assume that we want to read an OpenEXR image from a C
stdio file (of type <code>FILE&nbsp;*</code>) that has already been
opened.  To do this, we derive a new class, <code>C_IStream</code>,
from <code>IStream</code>.
The declaration of class <code>IStream</code> looks like this:

<pre><code>
    class IStream
    {
      public:

	virtual ~IStream ();

	virtual bool	read (char c[], int n) = 0;
	virtual Int64	tellg () = 0;
	virtual void	seekg (Int64 pos) = 0;
	virtual void	clear ();
	const char *	fileName () const;

      protected:

	IStream (const char fileName[]);

      private:

	...
    };
</code></pre>

Our derived class needs a public constructor,
and it must override four methods:
<p>

<pre><code>
    class C_IStream: public IStream
    {
      public:

	C_IStream (FILE *file, const char fileName[]):
	    IStream (fileName), _file (file) {}

	virtual bool	read (char c[], int n);
	virtual Int64	tellg ();
	virtual void	seekg (Int64 pos);
	virtual void	clear ();

      private:

	FILE *		_file;
    };
</code></pre>

<code>read(c,n)</code> reads <code>n</code> bytes from the file, and
stores them in array <code>c</code>.  If reading hits the end of the
file before <code>n</code> bytes have been read, or if an I/O error
occurs, <code>read(c,n)</code> throws an exception.
If <code>read(c,n)</code> hits the end of the file after reading
<code>n</code> bytes, it returns false, otherwise it returns true:

<pre><code>
    bool
    C_IStream::read (char c[], int n)
    {
	if (n != fread (c, 1, n, _file))
	{
	    // fread() failed, but the return value does not distinguish
	    // between I/O errors and end of file, so we call ferror() to
	    // determine what happened.

	    if (ferror (_file))
		Iex::throwErrnoExc();
	    else
		throw Iex::InputExc ("Unexpected end of file.");
	}

	return feof (_file);
    }
</code></pre>

<code>tellg()</code> returns the current reading position, in bytes,
from the beginning of the file.  The next call to <code>read()</code>
will begin reading at the indicated position:

<pre><code>
    Int64
    C_IStream::tellg ()
    {
	return ftell (_file);
    }
</code></pre>

<code>seekg(pos)</code> sets the current reading position to
<code>pos</code> bytes from the beginning of the file:

<pre><code>
    void
    C_IStream::seekg (Int64 pos)
    {
	clearerr (_file);
	fseek (_file, pos, SEEK_SET);
    }
</code></pre>

<code>clear()</code> clears any error flags that may be set
on the file after a <code>read()</code> or <code>seekg()</code>
operation has failed:

<pre><code>
    void
    C_IStream::clear ()
    {
	clearerr (_file);
    }
</code></pre>

In order to read an RGBA image from an open C stdio file, we first make a
<code>C_IStream</code> object.  Then we create an <code>RgbaInputFile</code>,
passing the <code>C_IStream</code> instead of a file name to the constructor.
After that, we read the image as usual
(see <a href = #sec_1_4>section 1.4, Reading an RGBA Image File</a>):

<pre><code>
    void
    readRgbaFILE (FILE *cfile,
		  const char fileName[],
		  Array2D<Rgba> &amp;pixels,
		  int &amp;width,
		  int &amp;height)
    {
	C_IStream istr (cfile, fileName);
	RgbaInputFile file (istr);

	Box2i dw = file.dataWindow();
	width  = dw.max.x - dw.min.x + 1;
	height = dw.max.y - dw.min.y + 1;
	pixels.resizeErase (height, width);
	file.setFrameBuffer (&amp;pixels[0][0] - dw.min.x - dw.min.y * width, 1, width);
	file.readPixels (dw.min.y, dw.max.y);
    }
</code></pre>

<a name = sec_6_3><h4>6.3 Preview Images</h4></a>
<p>

Graphical user interfaces for selecting image files often represent
files as small preview or "thumbnail" images.  In order to make loading
and displaying the preview images fast, OpenEXR files support storing
preview images in the file headers.
<p>

A preview image is an attribute whose value is of type
<code>PreviewImage</code>.
A <code>PreviewImage</code> object is an array of pixels of type
<code>PreviewRgba</code>.
A pixel has four components, <code>r</code>, <code>g</code>,
<code>b</code> and <code>a</code>, of type <code>unsigned char</code>,
where <code>r</code>, <code>g</code> and <code>b</code> are the
pixel's red, green and blue components, encoded with a gamma of 2.2.
<code>a</code> is the pixel's alpha channel;
<code>r</code>, <code>g</code> and <code>b</code> should be
premultiplied by <code>a</code>.
On a typical display with 8-bits per component, the preview image
can be shown by simply loading the
<code>r</code>, <code>g</code> and <code>b</code> components into the
display's frame buffer.  (No gamma correction or tone mapping is required.)
<p>

The code fragment below shows how to test if an OpenEXR file
has a preview image, and how to access a preview image's pixels:
<p>

<pre><code>
    RgbaInputFile file (fileName);

    if (file.header().hasPreviewImage())
    {
	const PreviewImage &amp;preview = file.header().previewImage();

	for (int y = 0; y &lt; preview.height(); ++y)
	    for (int x = 0; x &lt; preview.width(); ++x)
	    {
		const PreviewRgba &amp;pixel = preview.pixel (x, y);
		... 
	    }
    }
</code></pre>

Writing an OpenEXR file with a preview image is shown in the following
example.  Since the preview image is an attribute in the file's header,
it is entirely separate from the main image.  Here the preview
image is a smaller version of the main image, but this is not required;
in some cases storing an easily recognizable icon may be more appropriate.
This example uses the RGBA-only interface to write a scan-line based
file, but preview images are also supported for files that are written
using the general interface, and for tiled files.
<p>

<pre><code>
    void
    writeRgbaWithPreview1 (const char fileName[],
			   const Array2D <Rgba> &amp;pixels,
			   int width,
			   int height)
    {
	Array2D &lt;PreviewRgba&gt; previewPixels;					    // 1
	int previewWidth;							    // 2
	int previewHeight;							    // 3

	makePreviewImage (pixels, width, height,				    // 4
			  previewPixels, previewWidth, previewHeight);

	Header header (width, height);						    // 5

	header.setPreviewImage							    // 6
	    (PreviewImage (previewWidth, previewHeight, &amp;previewPixels[0][0]));

	RgbaOutputFile file (fileName, header, WRITE_RGBA);			    // 7
	file.setFrameBuffer (&amp;pixels[0][0], 1, width);				    // 8
	file.writePixels (height);						    // 9
    }
</code></pre>

Lines 1 through 4 generate the preview image.
Line 5 creates a header for the image file.
Line 6 converts the preview image into a <code>PreviewImage</code>
attribute, and adds the attribute to the header.
Lines 7 through 9 store the header (with the preview image) and
the main image in a file.
<p>

Function <code>makePreviewImage()</code>, called in line 4,
generates the preview image by scaling the main image down
to one eighth of its original width and height:
<p>

<pre><code>
    void
    makePreviewImage (const Array2D <Rgba> &amp;pixels,
		      int width,
		      int height,
		      Array2D <PreviewRgba> &amp;previewPixels,
		      int &amp;previewWidth,
		      int &amp;previewHeight)
    {
	const int N = 8;

	previewWidth  = width / N;
	previewHeight = height / N;
	previewPixels.resizeErase (previewHeight, previewWidth);

	for (int y = 0; y &lt; previewHeight; ++y)
	{
	    for (int x = 0; x &lt; previewWidth; ++x)
	    {
		const Rgba  &amp;inPixel = pixels[y * N][x * N];
		PreviewRgba &amp;outPixel = previewPixels[y][x];

		outPixel.r = gamma (inPixel.r);
		outPixel.g = gamma (inPixel.g);
		outPixel.b = gamma (inPixel.b);
		outPixel.a = int (clamp (inPixel.a * 255.f, 0.f, 255.f) + 0.5f);
	    }
	}
    }
</code></pre>

To make this example easier to read, scaling the image is
done by just sampling every eighth pixel of every eighth scan line.
This can lead to aliasing artifacts in the preview image; for a
higher-quality preview image, the main image should be lowpass-filtered
before it is subsampled.
<p>

Function <code>makePreviewImage()</code> calls <code>gamma()</code>
to convert the floating-point red, green, and blue components of the
sampled main image pixels to <code>unsigned char</code> values.
<code>gamma()</code> is a simplified version of what the exrdisplay
program does in order to show an OpenEXR image's floating-point
pixels on the screen (for details, see exrdisplay's source code):
<p>

<pre><code>
    unsigned char
    gamma (float x)
    {
	x = pow (5.5555f * max (0.f, x), 0.4545f) * 84.66f;
	return (unsigned char) clamp (x, 0.f, 255.f);
    }
</code></pre>

<code>makePreviewImage()</code> converts the pixels' alpha component
to <code>unsigned char</code> by by linearly mapping the range
[0.0,&nbsp;1.0] to [0,&nbsp;255].
<p>

Some programs write image files one scan line or tile at a time,
while the image is being generated.
Since the image does not yet exist when the file is opened for
writing, it is not possible to store a preview image in the
file's header at this time (unless the preview image is an icon
that has nothing to do with the main image).
However, it is possible to store a blank preview image in the header
when the file is opened.
The preview image can then be updated as the pixels become available.
This is demonstrated in the following example:
<p>

<pre><code>
    void
    writeRgbaWithPreview2 (const char fileName[],
			   int width,
			   int height)
    {
	Array &lt;Rgba&gt; pixels (width);

	const int N = 8;					 

	int previewWidth = width / N;
	int previewHeight = height / N;
	Array2D &lt;PreviewRgba&gt; previewPixels (previewHeight, previewWidth);

	Header header (width, height);
	header.setPreviewImage (PreviewImage (previewWidth, previewHeight));

	RgbaOutputFile file (fileName, header, WRITE_RGBA);
	file.setFrameBuffer (pixels, 1, 0);

	for (int y = 0; y &lt; height; ++y)
	{
	    generatePixels (pixels, width, height, y);
	    file.writePixels (1);

	    if (y % N == 0)
	    {
		for (int x = 0; x &lt; width; x += N)
		{
		    const Rgba  &amp;inPixel = pixels[x];
		    PreviewRgba &amp;outPixel = previewPixels[y / N][x / N];

		    outPixel.r = gamma (inPixel.r);
		    outPixel.g = gamma (inPixel.g);
		    outPixel.b = gamma (inPixel.b);
		    outPixel.a = int (clamp (inPixel.a * 255.f, 0.f, 255.f) + 0.5f);
		}
	    }
	}

	file.updatePreviewImage (&amp;previewPixels[0][0]);
    }
</code></pre>
<p>

<a name = sec_6_4><h4>6.4 Environment Maps</h4></a>

An environment map is an image that represents an omnidirectional
view of a three-dimensional scene, as seen from a particular 3D
location.  Every pixel in the image corresponds to a 3D direction,
and the data stored in the pixel represent the amount of light
arriving from this direction.
In 3D rendering applications, environment maps are often used
for image-based lighting techniques that appoximate how objects
are illuminated by their surroundings.
Environment maps with enough dynamic range to represent even the
brightest light sources in the environment are sometimes called
"light probe images."
<p>

In an OpenEXR file, an environment map is stored as a rectangular
pixel array, just like any other image, but an attribute in the
file header indicates that the image is an environment map.
The attribute's value, which is of type <code>Envmap</code>,
specifies the relation between 2D pixel locations and 3D directions.
<code>Envmap</code> is an enumeration type.
Two values are possible:
<p>

<table>
<tr>
<td valign="top"><code>ENVMAP_LATLONG</code></td>

<td valign="top">
    Latitude-Longitude Map:

    The environment is projected onto the image using polar coordinates
    (latitude and longitude).  A pixel's x coordinate corresponds to
    its longitude, and the y coordinate corresponds to its latitude.
    The pixel in the upper left corner of the data window has latitude
    +&pi;/2 and longitude +&pi;; the pixel in the lower right corner
    has latitude -&pi;/2 and longitude -&pi;.
    <p>

    In 3D space, latitudes -&pi;/2 and +&pi;/2 correspond to the negative and
    positive y direction.  Latitude 0, longitude 0 points in the positive
    z direction; latitude 0, longitude &pi;/2 points in the positive
    x direction.
    <p>

    For a latitude-longitude map, the size of the data window should
    be 2&times;N by N pixels (width by height), where N can be any integer
    greater than 0.
    <p>

    <img src="images/latlongMap.png">
    <p>
</td>

<tr>
<td valign="top"><code>ENVMAP_CUBE</code></td>

<td valign="top">
    Cube Map:

    The environment is projected onto the six faces of an
    axis-aligned cube.  The cube's faces are then arranged
    in a 2D image as shown below.
    <p>
    For a cube map, the size of the data window should be N by 6&times;N
    pixels (width by height), where N can be any integer greater than 0.
    <p>

    <img src="images/cubeMap.png">
</td>
</tr>
</table>
<p>

The following code fragment tests if an OpenEXR file contains an
environment map, and if it does, which kind:
<p>

<pre><code>
    RgbaInputFile file (fileName);

    if (hasEnvmap (file.header()))
    {
	Envmap type = envmap (file.header());
	...
    }
</code></pre>

For each kind of environment map, the IlmImf library provides a set of
routines that convert from 3D directions to 2D floating-point pixel
locations and back.
Those routines are useful in application programs that create
environment maps, and in programs that perform map lookups.
For details, see header file <code>ImfEnvmap.h</code>.
<p>
</body>
</html>
